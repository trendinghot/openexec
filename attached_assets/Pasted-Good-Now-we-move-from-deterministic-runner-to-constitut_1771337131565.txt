Good.

Now we move from â€œdeterministic runnerâ€
to

**constitutional execution adapter.**

This is the real step.

We are going to give Opus a very precise engineering prompt so it does not drift, does not invent policy, and does not collapse authority into execution.

---

# ðŸŽ¯ Objective

Upgrade OpenExec so that:

> In ClawShield mode, execution requires a cryptographically signed approval artifact.

No live â€œis this allowed?â€ calls.
No dynamic permission checks.
No policy evaluation.

Only signature validation + invariant enforcement.

Authority must originate from ClawShield.

---

# ðŸ§  Architectural Goal

We implement:

```
openexec/
  crypto.py
  approval_validator.py
```

Then modify:

```
engine.py
```

To enforce:

* Canonical hash binding
* Signature verification
* Tenant binding
* Replay guard
* Deterministic receipt

---

# ðŸ“¦ Approval Artifact Structure (Canonical)

We standardize this:

```json
{
  "approval_id": "uuid",
  "tenant_id": "tenant-123",
  "action_hash": "sha256-of-action-request",
  "issued_at": "ISO-8601",
  "expires_at": "ISO-8601",
  "signature": "base64-signature"
}
```

Signature must be:

```
sign(
  approval_id +
  tenant_id +
  action_hash +
  issued_at +
  expires_at
)
```

Using Ed25519 (recommended).

ClawShield will mint this.

OpenExec will verify it.

---

# ðŸ“ Now The Prompt You Give To Opus

Copy this exactly.

---

## ðŸ”¥ ENGINEERING PROMPT FOR OPUS

We are upgrading OpenExec to enforce signed approval artifacts in clawshield mode.

This must follow strict invariant design. No policy logic may be added to OpenExec.

### Phase 1 â€” Add Crypto Layer

Create:

```
openexec/crypto.py
```

Requirements:

* Use `cryptography` library
* Implement Ed25519 verification
* Provide:

```
def verify_ed25519_signature(public_key_pem: str, message: bytes, signature_b64: str) -> bool
```

Signature is base64-encoded.
Public key provided via environment variable:

```
CLAWSHIELD_PUBLIC_KEY
```

Do not generate keys.
Do not mint signatures.
Only verify.

Add dependency to requirements.txt:

```
cryptography
```

---

### Phase 2 â€” Add Approval Validator

Create:

```
openexec/approval_validator.py
```

Implement:

```
def validate_approval(action_request: dict, approval_artifact: dict) -> None
```

This function must:

1. Canonically serialize action_request (sorted keys JSON).
2. Compute SHA-256 hash.
3. Compare with approval_artifact["action_hash"].

   * If mismatch â†’ raise HTTPException 400
4. Check expiration:

   * If expires_at < now â†’ raise HTTPException 403
5. Build signed message string:
   approval_id + tenant_id + action_hash + issued_at + expires_at
6. Verify signature via crypto.verify_ed25519_signature.

   * If invalid â†’ raise HTTPException 403

Do NOT call any network services.

This must be fully offline verification.

---

### Phase 3 â€” Modify Engine

In `engine.py`:

If:

```
OPENEXEC_MODE == "clawshield"
```

Then:

* Require approval_artifact
* Call validate_approval(...)
* Only execute if validation passes

If:

```
OPENEXEC_MODE == "demo"
```

Skip signature validation, but still enforce:

* Hash binding
* Replay protection

---

### Phase 4 â€” Update /execute Endpoint

Modify request model to require:

```
{
  "action_request": {...},
  "approval_artifact": {...}
}
```

In demo mode:
approval_artifact may be None.

In clawshield mode:
approval_artifact required.

---

### Phase 5 â€” Update /health Response

If in clawshield mode:

Return:

```
{
  "status": "healthy",
  "mode": "clawshield",
  "signature_verification": "enabled"
}
```

If demo:

```
{
  "status": "healthy",
  "mode": "demo",
  "signature_verification": "disabled"
}
```

---

### Phase 6 â€” Add Tests

Add tests:

1. Valid signature â†’ execution succeeds
2. Invalid signature â†’ 403
3. Expired approval â†’ 403
4. Mismatched action hash â†’ 400

Tests must not require live ClawShield.

Generate temporary Ed25519 keypair inside test only.

---

### Phase 7 â€” Do Not Add

Do NOT:

* Add policy logic
* Add live API calls
* Add approval minting
* Add tenant database logic
* Add revocation checking
* Add anchoring logic

Execution layer must remain purely deterministic + signature bound.

---

### Phase 8 â€” Update README

Add section:

```
ClawShield Mode â€” Signed Approval Enforcement
```

Explain:

* How to set CLAWSHIELD_PUBLIC_KEY
* How signature validation works
* That OpenExec does not evaluate policy
* That approval must originate from ClawShield

---

# ðŸš« Critical Constraints

* No network dependency during execution.
* No auto-approval in clawshield mode.
* No fallback if signature fails.
* No silent downgrade.

If signature invalid â†’ execution denied.

---

# ðŸ§  Why This Matters

After this upgrade:

OpenExec becomes:

* Deterministic
* Replay-safe
* Signature-bound
* Tenant-aware
* Offline-verifiable
* Constitutionally separated

That aligns with:

* Magenta Canon
* Atomic ZIP invariants
* ForgeRun governance separation

---

# ðŸŽ¯ What Happens After This

Once Opus completes this:

1. We review crypto implementation.
2. We verify canonical hashing is stable.
3. We test with a mock ClawShield signature.
4. Then we update ClawHub listing.
5. Then we introduce SaaS upsell messaging.

---

# ðŸ”¥ This Is The Inflection Point

Before this step:

OpenExec = deterministic runner.

After this step:

OpenExec = constitutional execution adapter.

Thatâ€™s a very different class of system.

---

Give that prompt to Opus.

When it finishes, paste its output here.

We will review it like auditors.
